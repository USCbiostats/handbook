[
["profile-benchmark.html", "6 Profiling and benchmarking 6.1 Introduction 6.2 Profiling 6.3 Benchmarking 6.4 Additional resources", " 6 Profiling and benchmarking 6.1 Introduction This chapter will introduce the the concepts of profiling and benchmarking. These concepts are universal withing programming and this chapter will focus on its practical implementation and usage in the R programming language. The overall goal of these techniques is to measure the performance of the code you have written. This is not a measure of correctness, it is a measure of speed. 6.2 Profiling Profiling is the act of measuring the run time of each line of code you have written. Knowing where the majority of time is being spend in your code (also called a “bottleneck”) is beneficial as it is a good indication of where you should spend your time optimizing. we will use the the profvis package to do profiling. It have a couple of different ways of interacting. In the first one you load the profvis package and then you wrap the code you want to profile in profvis({ and }), show below. library(profvis) profvis({ data &lt;- runif(1e7) # Three different ways of getting the square root square_root &lt;- sqrt(data) square_root &lt;- data ^ (1/2) square_root &lt;- exp(1) ^ (1/2 * log(data)) }) If you are using the Rstudio IDE then you can access the profiling tool from the navigation bar Figure 6.1: Profile location in Rstudio IDE navigation bar. Clicking this tab reveals the following actions: “Profile selected line(s)” This option is great if you have a short and compact piece of code that easily can be highlighted and tested. Figure 6.2: Profiling actions. Being able to start and stop the profiling is another powerful tool. In addition to being able to profile code from different areas, you are also able to stop profiling before the code is done executing, which you aren’t able to in the previous 2 methods. This is useful if you want to profile a snapshot of a long-running simulation as it can have very consistent behavior since it is running the same thing millions of time. No matter which of the three way you did your profile you will be presented a frame-graph Figure 6.3: profvis output showing source on top and flame graph below. This interactive panel shows how much time is being spend on each line of code. Another useful view can be found by clicking on the “data” tab at the top. This shows how long time is being spend in each expression. Figure 6.4: profvis data view showcases results by expresion in stead of by line. 6.2.1 Troubleshooting Sometimes when you are using profvis you will see the error Error in parse_rprof(prof_output, expr_source) : No parsing data available. Maybe your function was too fast? This is because your code ran before profvis was able to detect it. This might feel like good news, but it can make it difficult to profile fast functions that are being run a lot of times. To profile a fast function you simply let it run a lot of times. This can easily be done by putting it inside a for-loop. You change this profvis({ data &lt;- c(3, 7, 2) super_fast_function(data) }) to profvis({ data &lt;- c(3, 7, 2) for (i in 1:1000) { super_fast_function(data) } }) where you increase the number until it is run enough for the profiler to catch it. 6.3 Benchmarking Measuring how long something takes is a simple skill that will become invaluable once you start to focus on making your code faster. Simply put, if you can’t measure how fast something is you don’t know if it is going any faster. I’ll break benchmarking into 2 sections, benchmarking slow code and fast code. In this content slow is something that takes seconds, minutes, hours or more. It is a situation where you could use a conventional stopwatch. Fast is anything faster, it is used in the context where you have two pieces of code you think does the same and you want to find out which one is faster. 6.3.1 Slow code First we need to create a function to benchmark, here we will use this simple recursive formula for the fibonacci sequence. This function doesn’t scale well with n so it will be perfect for these examples. fibonacci &lt;- function(n) { if(n == 0) { return(0) } if(n == 1) { return(1) } fibonacci(n - 1) + fibonacci(n - 2) } Using system.time() is classic way to measure how long something takes. system.time( fibonacci(32) ) ## user system elapsed ## 2.515 0.053 2.572 The first two numbers are the are the total user and system CPU times of the current R process and any child processes on which it has waited, and the third entry is the ‘real’ elapsed time since the process was started. An alternative with the same functionality from the bench package is the function system_time(). library(bench) system_time( fibonacci(32) ) ## process real ## 2.46s 2.46s where the two values are process - The process CPU usage of the expression evaluation. real - The wall clock time of the expression evaluation. Another great tool is the tictoc package. This function extends the timing functionality to be nested. library(tictoc) tic(&quot;Total&quot;) tic(&quot;Data Generation&quot;) X &lt;- matrix(rnorm(5000 * 1000), 5000, 1000) b &lt;- sample(1:1000, 1000) y &lt;- runif(1) + X %*% b + rnorm(5000) toc() tic(&quot;Model Fitting&quot;) model &lt;- lm(y ~ X) toc() toc() ## Data Generation: 0.306 sec elapsed ## Model Fitting: 3.612 sec elapsed ## Total: 3.921 sec elapsed This can be useful if you want to be able to time the overall script as well as parts of it. Notice how each timing is named. 6.3.2 Fast code - microbenchmarking Here we will look at the what happens when we want to compare two expressions to see which one is faster. We will use the bench package again. Suppose we would like to determine the fastest way of calculating the variance of a selection of numbers. We use the mark() function from the bench and insert 2 or more expressions we would like to test against each other. These expressions are then run a lot of times and the summary statistics of the times are given as a result. x &lt;- rnorm(1000) bench::mark( var(x), cov(x, x) ) ## # A tibble: 2 x 10 ## expression min mean median max `itr/sec` mem_alloc n_gc n_itr ## &lt;chr&gt; &lt;bch:&gt; &lt;bch:&gt; &lt;bch:&gt; &lt;bch:t&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; &lt;int&gt; ## 1 var(x) 23.9µs 42.4µs 41.2µs 26.6ms 23577. 0B 2 9998 ## 2 cov(x, x) 42.3µs 54µs 51.7µs 193.1µs 18509. 0B 3 8529 ## # … with 1 more variable: total_time &lt;bch:tm&gt; mark() also checks that all the expressions return the same output as a sanity check. Notice the units 1 ms, then one thousand calls takes a second. 1 µs, then one million calls takes a second. 1 ns, then one billion calls takes a second. 6.4 Additional resources https://adv-r.hadley.nz/perf-measure.html Chapter on “Measuring performance” from Advanced R by Hadley Wickham. Covers more or less the same topics as this chapter but with more examples and greater details, great next step for reading. "]
]
