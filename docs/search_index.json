[
["index.html", "USC biostats R Handbook 1 Welcome", " USC biostats R Handbook Emil Hvitfeldt Spring 2019 1 Welcome TODO How to contribute "],
["coding-standards.html", "2 Coding Standards 2.1 General overview 2.2 Helpful suggestions", " 2 Coding Standards This chapter will outline standards we aim to adhere to. In addition to these standards will be some suggestions on best practices we hopes you will find useful. 2.1 General overview Try to keep your code to less then 80 characters per line. This will improve visibility as the code willm fit on your screen when you are working. If you are using Rstudio, you can add a visual marker on the 80 character line. Click Rstudio -&gt; Preferences -&gt; Code -&gt; display -&gt; Show margin. document your code. Explain yourself. Each function should have acommpanying documentation explaning what it is doing. This will help other people understand what your code is doing without having to look at the code indside the function. Notice that “other people” also describes “future you”. Use white space for indenting, 2 characters. When possible, structure your code as sections/files, with files holding similar functions and sections to give internal structure to your file. Include a informative README in each project. 2.2 Helpful suggestions Use a integrated development environment (IDE). We recommend https://www.rstudio.com/. TODO explain what the benefits of using a IDE. If you are looking for a coding style, then the The tidyverse style guide is a good place to start. "],
["building-a-r-package.html", "3 Building a R package 3.1 Motivation 3.2 Preperation 3.3 Minimal R Package 3.4 Additional Components 3.5 Resources", " 3 Building a R package 3.1 Motivation This chapter will show you how to create a R package with varrying number of additions. From a simple minimal package for personal use to a fully-fleshed package. Creating a R package is not only done for publication. It also helps you stay organizes, save yourself time while still letting you share your code with other people. Learning what goes into creating a package can be a mouthful at first but the conventions and rules revolving around packages makes the creation easy. 3.2 Preperation To get started it would be preferriable for you to have git installed on your machine and have a Github account. https://happygitwithr.com/ provides a brilliant and thorough walkthrough of using git/Github with R. In addition to git, you will also need the following packages install.packages(c(&quot;devtools&quot;, &quot;roxygen2&quot;, &quot;testthat&quot;, &quot;knitr&quot;)) If you are planning on using compiled code you will need to install the following depending on your operating system: On Windows, download and install Rtools. On Mac, download and install XCode (available for free in the App Store) or the Command Line Tools for Xcode. On Linux, download and install the R development tools. 3.2.1 Naming your R package When creating a package you need to give it at name. The name can only consist of letters, numbers and periods must start with a letter, and cannot end with a period Furthermore we recommend that you don’t use periods and stick with letters as much as possible. You need a unique name, mainly because of the fact that if you plan on getting your package on CRAN or bioconductor you can’t overlap with any of their names. A easy check for can be done using the available package. available also checks across acronyms, slang and other meanings that you might have missed. Secondly try to pick a name that is googleable. 3.3 Minimal R Package Creating a package can easily be done using the usethis package, all you need is to provide a path to the directory you want the pacakge to be created in. create_package(&quot;~/path/to/packagename&quot;) If you are using Rstudio you should already be transported to a project at the specified location with the following content For now we will focus on the /R folder and the DESCRIPTION files as the remaining files/folders should be automatically modified if we use usethis. The DESCRIPTION is our first stop. You should make yourself the author, Authors@R: person(&quot;given name&quot;, &quot;family name&quot;, role = c(&quot;aut&quot;, &quot;cre&quot;), &quot;contact@mail.com&quot;) The roles aut and cre stand for author and creator respectively. More details regarding use of roles can be found here. Next you need to fill in the Title and Description fields. The Title should be a short and simple description of the package. Must be plain text, title-case (This Sentence Is Title Case), not end in a period and should preferable be les then 65 characters. The Description fields is the more detailed version of the Title field. It should span multiple lines, each indented 4 spaces (first excluded) and being less then 80 characters long. This is a fairly limited space so further details should be included in the readme. The package created here doesn’t provide anything in terms of functions or data. Adding these objects will be the subject of the next section. 3.4 Additional Components This section will introduce various components you can include in your package to improve its functionality and useability. 3.4.1 R code R/ 3.4.2 README 3.5 Resources Usethis package https://github.com/r-lib/usethis Writing a R package slides https://github.com/jalapic/RPackage/blob/master/Writing%20an%20R%20Package.pdf Cran documentation https://cran.r-project.org/doc/manuals/R-exts.html Pick a license https://blog.codinghorror.com/pick-a-license-any-license/ https://choosealicense.com/licenses/ https://tldrlegal.com/ https://cran.r-project.org/doc/manuals/R-exts.html#The-DESCRIPTION-file Build a Basic Package http://rpubs.com/jennybc/build-a-basic-package Deployment options https://twitter.com/WeAreRLadies/status/1110694338068140032 R Packages https://r-pkgs.org/ https://www.hvitfeldt.me/blog/usethis-workflow-for-package-development/ https://usethis.r-lib.org/ You can make a package in 20 minutes - Rstudio Conf Talk by Jim Hester https://www.rstudio.com/resources/videos/you-can-make-a-package-in-20-minutes/ https://hilaryparker.com/2014/04/29/writing-an-r-package-from-scratch/ https://cran.r-project.org/doc/manuals/r-release/R-exts.html https://ropensci.github.io/dev_guide/ https://ropensci.org/blog/2018/03/16/thanking-reviewers-in-metadata/ "],
["parallel-computing.html", "4 Parallel computing", " 4 Parallel computing "],
["testing.html", "5 Testing", " 5 Testing "],
["profile-benchmark.html", "6 Profiling and benchmarking 6.1 Introduction 6.2 Profiling 6.3 Benchmarking 6.4 Additional resources", " 6 Profiling and benchmarking 6.1 Introduction This chapter will introduce the the concepts of profiling and benchmarking. These concepts are universal withing programming . This chapter will focus on its practical implementation and usage in the R programming language. The overall goal of these techniques is to measure the performance of the code you have written. Remember this is a measure of speed, not a measure of correctness. 6.2 Profiling Profiling is the act of measuring the run-time of each line of code you have run. Knowing where the time is being spend in your code is beneficial as it is a good indication of where you should spend your time optimizing. In general you want to look for small areas that take up most of the time (also called a “bottleneck”) and focus on those before other parts. There is little reason to spend time optimizing a piece of code that only take up 0.1% of the time when you could work at a piece that takes up 70% of the time. We will use the the profvis package to do profiling. It have a couple of different ways of interacting. In the first one you load the profvis package and then you wrap the code you want to profile in profvis({ and }) as shown below show below. library(profvis) profvis({ data &lt;- runif(1e7) # Three different ways of getting the square root square_root &lt;- sqrt(data) square_root &lt;- data ^ (1/2) square_root &lt;- exp(1) ^ (1/2 * log(data)) }) Another way if you are using the Rstudio IDE, comes from the navigation bar where you can access the profiling tool. Figure 6.1: Profile location in Rstudio IDE navigation bar. Clicking this tab reveals the following actions: “Profile selected line(s)” “Start profiling” &amp; “Stop profiling” Figure 6.2: Profiling actions. Being able to profile selected lines of code is great if you have a short and compact piece of code that easily can be highlighted and tested. On the other hand is the ability start and stop the profiling whenever you want a powerful tool. In addition to being able to profile code from different areas, you are also able to stop profiling before the code is done executing, which you aren’t able to in the previous 2 methods. This is useful if you want to profile a snapshot of a long-running simulation as it can have very consistent behavior since it is running the same thing millions of time. No matter which of the three way you do your profile you will be presented with a page with a frame-graph Figure 6.3: profvis output showing source on top and flame graph below. This interactive panel shows how much time and memory is being spend on each line of code. From here you should be able to identify Another useful view can be found by clicking on the “data” tab at the top. This shows how long time is being spend in each expression. We can see in this example that the power operator ^ is taking the majority of the time. Figure 6.4: profvis data view showcases results by expresion in stead of by line. 6.2.1 Troubleshooting Sometimes when you are using profvis you will see the error Error in parse_rprof(prof_output, expr_source) : No parsing data available. Maybe your function was too fast? This is because your code finished running before profvis was able to detect it. This might feel like good news, but it can make it difficult to profile very fast functions. To profile a fast function you simply let it run a lot of times. This can easily be done by putting it inside a for-loop. You change this profvis({ data &lt;- c(3, 7, 2) super_fast_function(data) }) to profvis({ data &lt;- c(3, 7, 2) for (i in 1:1000) { super_fast_function(data) } }) where you increase the number until it is run enough for the profiler to catch it. 6.3 Benchmarking Measuring how long something takes is a simple skill that will become invaluable once you start to focus on making your code faster. Simply put, if you can’t measure how fast something is you don’t know if it is going any faster. This section will be broken into 2 sections benchmarking slow code and, benchmarking fast code. In this content slow is something that takes seconds, minutes, hours or more. It is a situation where you could use a conventional stopwatch. Fast is anything faster, it is used in the context where you have two pieces of code you think does the same and you want to find out which one is faster. 6.3.1 Slow code First we need to create a function to benchmark, here we will use this simple recursive formula for the fibonacci sequence. This function doesn’t scale well with n so it will be perfect for these examples. fibonacci &lt;- function(n) { if(n == 0) { return(0) } if(n == 1) { return(1) } fibonacci(n - 1) + fibonacci(n - 2) } Using system.time() is classic way to measure how long something takes, simple wrap the code you want to time between system.time({ and }). system.time({ fibonacci(32) }) ## user system elapsed ## 2.185 0.017 2.205 The first two numbers are the are the total user and system CPU times of the current R process and any child processes on which it has waited, and the third entry is the ‘real’ elapsed time since the process was started. An alternative with the same functionality from the bench package is the function system_time(). library(bench) system_time({ fibonacci(32) }) ## process real ## 2.1s 2.1s where the two values are process - The process CPU usage of the expression evaluation. real - The wall clock time of the expression evaluation. Another great tool is the tictoc package. Simply call tic() when to start recording and toc() to end recording. library(tictoc) tic() x &lt;- fibonacci(32) toc() ## 2.731 sec elapsed In addition does this package extend the timing functionality in such a way that we are able to measure times in nested context. In the following example we are generating some data and fitting a model. Calling tic() another time before the toc() allows us to measure subsections of the whole. library(tictoc) tic(&quot;Total&quot;) tic(&quot;Data Generation&quot;) X &lt;- matrix(rnorm(5000 * 1000), 5000, 1000) b &lt;- sample(1:1000, 1000) y &lt;- runif(1) + X %*% b + rnorm(5000) toc() tic(&quot;Model Fitting&quot;) model &lt;- lm(y ~ X) toc() toc() ## Data Generation: 0.397 sec elapsed ## Model Fitting: 4.005 sec elapsed ## Total: 4.404 sec elapsed This can be useful if you want to be able to time the overall script as well as parts of it. Notice how each timing is named. 6.3.2 Fast code - microbenchmarking Here we will look at the what happens when we want to compare two expressions to see which one is faster. We will use the bench package again. Suppose we would like to determine the fastest way of calculating the variance of a selection of numbers. We use the mark() function from the bench and insert 2 or more expressions we would like to test against each other. These expressions are then run a lot of times and the summary statistics of the times are given as a result. library(bench) x &lt;- rnorm(1000) bench::mark( var(x), cov(x, x) ) ## # A tibble: 2 x 10 ## expression min mean median max `itr/sec` mem_alloc n_gc n_itr ## &lt;chr&gt; &lt;bch:&gt; &lt;bch:&gt; &lt;bch:&gt; &lt;bch&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; &lt;int&gt; ## 1 var(x) 23.8µs 29.2µs 28.5µs 132µs 34242. 13.7KB 6 9994 ## 2 cov(x, x) 43.3µs 54.5µs 52.5µs 214µs 18346. 47.5KB 10 8447 ## # … with 1 more variable: total_time &lt;bch:tm&gt; mark() also checks that all the expressions return the same output as a sanity check. Notice the units 1 ms, then one thousand calls takes a second. 1 µs, then one million calls takes a second. 1 ns, then one billion calls takes a second. 6.4 Additional resources https://adv-r.hadley.nz/perf-measure.html Chapter on “Measuring performance” from Advanced R by Hadley Wickham. Covers more or less the same topics as this chapter but with more examples and greater details, great next step for reading. "]
]
